'use strict';// Data Type Check
function isArray(a){return"object"==typeof a&&a.constructor===Array}function isNull(a){return null===a}function isNumber(a){return!isNaN(parseFloat(a))&&isFinite(a)}function isString(a){return"string"==typeof a}// Special keys
const special_keys={ctrl:17,backspace:8,tab:9,enter:13,shift:16,alt:18,capslock:20,escape:27,left:37,up:38,right:39,down:40,delete:46},keydown_options={together:"+",rotation:" "};// Separator of together or rotation keys
// Main object
let hotkeys_data={keys_rotation:[],keys_together:[],all_keys:[],key_rot:[],key_tog:[],timer:setTimeout(function(){},0),count:0,on:!0};// Checking the inner string and returning an array
function check_internal_str(a,b){let c=[];try{c=a.split(b)}catch(a){throw new Error("Invalid keys description "+a)}let d=c.map(a=>{let b=0;return b=special_keys[a]?special_keys[a]:/\{[0-9]*\}/.test(a)?+a.replace(/(^{*)|(}*)$/g,""):a.toUpperCase().charCodeAt(0),b});return d}// General line check
function check_hotkeys_str(a){const{together:b,rotation:c}=keydown_options;let d="",e=[];return-1<a.indexOf(b)?(e=check_internal_str(a,b),d="keys_together"):-1<a.indexOf(c)?(e=check_internal_str(a,c),d="keys_rotation"):special_keys[a]?(e=[special_keys[a]],d="keys_together"):1==a.length&&(e=[(a+"").toUpperCase().charCodeAt(0)],d="keys_together"),{arr_keys:e,curr_type:d}}// fill data in hotkeys
function filling_data(a,b){const{length:c}=hotkeys_data.all_keys,{arr_keys:d,curr_type:e}=check_hotkeys_str(a);let f=void 0===arguments[2]?{pressingOnce:!1}:arguments[2];let g={codes:d,name:a,func:b,curr_type:e,options:f};""!==e&&(hotkeys_data[e].push({codes:d,func_index:c}),hotkeys_data.all_keys.push(g))}// Handling onkeydown and onkeyup events
function eventKey(){let{key_rot:a,key_tog:b,keys_together:c,keys_rotation:d}=hotkeys_data;document.onkeydown=function(f){function e(a,b){let{key_rot:c,key_tog:d,all_keys:e}=hotkeys_data,f=-1;return a.forEach(({codes:a,func_index:d})=>{let e=a.every((a,c)=>a==b[c]);e&&(c.splice(0,c.length),f=d)}),f}let{on:g,all_keys:h}=hotkeys_data;if(!g)return;let i=f.which,{length:j}=b;a.push(i),b[b.length-1]!==i&&b.push(i);new Promise(function(f){let g=e(c,b),h=e(d,a),i=-1===g?h:g;f(i)}).then(a=>{if(-1!==a){let{name:c,codes:d,options:e}=h[a];e.pressingOnce&&(b=[],smart_clean_rot()),h[a].func.apply(this,[f,{name:c,codes:d}])}})},document.onkeyup=function(a){let{on:c}=hotkeys_data;if(c){let c=b.length-1;-1!=c&&b[c]==a.keyCode?b.pop():b=[],smart_clean_rot()}}}// Clearing key_rot via a timer
function smart_clean_rot(){let{key_rot:a}=hotkeys_data;clearTimeout(hotkeys_data.timer),hotkeys_data.timer=setTimeout(function(){a.splice(0,a.length)},1e3)}// Synchronization keys_rotation, keys_together from all_keys
function update_hotkeys(){let{all_keys:a,keys_rotation:b,keys_together:c}=hotkeys_data;b.splice(0,b.length),c.splice(0,c.length),a.forEach(({codes:a,curr_type:b},c)=>{hotkeys_data[b].push({codes:a,func_index:c})})}const hotkeys={// Add a new hotkey
add:function(a,b){hotkeys_data.count+=1,isArray(a)?a.forEach(a=>{filling_data(a,b,arguments[2])}):"string"==typeof a&&filling_data(a,b,arguments[2]),1==hotkeys_data.count&&eventKey()},// Delete hotkey
delete:function(a){function b(a){let{all_keys:b,keys_rotation:c,keys_together:d}=hotkeys_data,e=-1;b.forEach(({name:b},c)=>{b==a&&(e=c)}),-1!==e&&(b.splice(e,1),update_hotkeys())}isArray(a)?a.forEach(b):isString(a)&&b(a)},// Change name and function of hotkey
change:function(a,b){let{all_keys:c}=hotkeys_data,d=-1;if(c.forEach(({codes:b,name:c},e)=>{a==c&&(d=e)}),-1!==d){if(null!==b){const{arr_keys:a,curr_type:e}=check_hotkeys_str(b);""!==e&&(c[d].name=b,c[d].codes=a)}void 0!==arguments[2]&&"function"==typeof arguments[2]&&null!==arguments[2]&&(c[d].func=arguments[2]),void 0!==arguments[3]&&"object"==typeof arguments[3]&&null!==arguments[3]&&(c[d].options=arguments[3]),update_hotkeys()}},// enable
enable:function(){hotkeys_data.on=!0},// disable
disable:function(){hotkeys_data.on=!1}};// module.exports = { hotkeys };